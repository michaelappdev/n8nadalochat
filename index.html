<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>n8n Chat Wrapper</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- n8n Chat CSS -->
    <link href="https://cdn.jsdelivr.net/npm/@n8n/chat/dist/style.css" rel="stylesheet" />
    <style>
      /* Ensure fullscreen works when mode=fullscreen */
      html, body { margin: 0; padding: 0; height: 100%; }
      #n8n-chat { height: 100%; }
      /* Default theme (overridable via cssVar.* query params) */
      :root {
        --chat--color-primary: #4338CA !important;
        --chat--color-secondary: #4338CA !important;
        --chat--toggle--background: #4338CA !important;
        --chat--toggle--hover--background: #3726A6 !important;
        --chat--toggle--active--background: #301E8A !important;
        --chat--button--background: #4338CA !important;
        --chat--button--color: #ffffff !important;
        --chat--header--background: #4338CA !important;
        --chat--header--color: #ffffff !important;
        --chat--message--user--background: #4338CA !important;
        --chat--message--user--color: #ffffff !important;
      }
      /* Also set on the host element so it pierces the shadow DOM */
      #n8n-chat {
        --chat--color-primary: #4338CA !important;
        --chat--color-secondary: #4338CA !important;
        --chat--toggle--background: #4338CA !important;
        --chat--toggle--hover--background: #3726A6 !important;
        --chat--toggle--active--background: #301E8A !important;
        --chat--button--background: #4338CA !important;
        --chat--button--color: #ffffff !important;
        --chat--header--background: #4338CA !important;
        --chat--header--color: #ffffff !important;
        --chat--message--user--background: #4338CA !important;
        --chat--message--user--color: #ffffff !important;
      }
    </style>
  </head>
  <body>
    <!-- Default mount target -->
    <div id="n8n-chat"></div>

    <script type="module">
      import { createChat } from 'https://cdn.jsdelivr.net/npm/@n8n/chat/dist/chat.bundle.es.js';

      const params = new URLSearchParams(location.search);

      // Helpers
      const get = (k, d = undefined) => params.get(k) ?? d;
      const has = (k) => params.has(k);
      const toBool = (v, d = false) => {
        if (v == null) return d;
        const s = String(v).trim().toLowerCase();
        return ['1','true','yes','y','on'].includes(s);
      };
      const parseJSON = (str) => {
        try { return JSON.parse(str); } catch { return undefined; }
      };
      const fromBase64 = (input) => {
        if (input == null) return undefined;
        try {
          let b64 = String(input);
          // Normalize base64url (RFC 4648) to standard base64 for atob
          b64 = b64.replace(/-/g, '+').replace(/_/g, '/');
          // Add padding if missing
          const mod = b64.length % 4;
          if (mod === 2) b64 += '==';
          else if (mod === 3) b64 += '=';
          else if (mod === 1) return undefined; // invalid length
          return atob(b64);
        } catch { return undefined; }
      };
      // Prefer ...B64 > ...Json > raw JSON in param
      const getComplex = (baseName) => {
        if (has(baseName + 'B64')) {
          const decoded = fromBase64(get(baseName + 'B64'));
          if (decoded) {
            const obj = parseJSON(decoded);
            if (obj) return obj;
          }
        }
        if (has(baseName + 'Json')) {
          const obj = parseJSON(get(baseName + 'Json'));
          if (obj) return obj;
        }
        // As a last resort, try parsing the raw value
        if (has(baseName)) {
          const raw = get(baseName);
          const obj = parseJSON(raw);
          if (obj) return obj;
        }
        return undefined;
      };
      const normalizeMode = (m) => {
        const v = String(m || '').toLowerCase();
        if (v === 'full' || v === 'fs') return 'fullscreen';
        return m;
      };

      // Determine target early so we can apply CSS vars to it too
      const targetSelector = get('target', '#n8n-chat');

      // Apply CSS variables via query params:
      // Any param like cssVar.<name>=<value> becomes --chat--<name>: <value>
      // Example: cssVar.window--width=480px => --chat--window--width: 480px
      const applyCssVars = (styleTarget) => {
        for (const [key, value] of params.entries()) {
          if (key.startsWith('cssVar.')) {
            const varName = key.slice('cssVar.'.length);
            if (varName) styleTarget.style.setProperty(`--chat--${varName}`, value, 'important');
          }
        }
      };
      // Apply to :root
      applyCssVars(document.documentElement);
      // Also apply to the target element (if present)
      const targetEl = document.querySelector(targetSelector);
      if (targetEl) applyCssVars(targetEl);

      // Required (support aliases + base64)
      const webhookUrl = (
        get('webhookUrl') ??
        fromBase64(get('webhookUrlB64')) ??
        get('webhook') ??
        get('wh') ??
        get('url')
      );
      if (!webhookUrl) {
        const msg = 'Missing required "webhookUrl" (aliases: webhookUrlB64, webhook, wh, url).';
        console.error(msg);
        const el = document.getElementById('n8n-chat');
        if (el) el.textContent = msg;
        throw new Error(msg);
      }

      // webhookConfig: method + headers
      const method = get('method', 'POST');
      const headers = getComplex('headers') || {}; // headersJson / headersB64 / headers

      // Normalize mode aliases with fullscreen as default
      const mode = normalizeMode(get('mode', 'fullscreen'));

      // Metadata shorthands merged onto complex metadata
      const resolvedMetadata = (() => {
        const meta = getComplex('metadata') || {};
        const proj = get('projectid') ?? get('projectId');
        if (proj != null && meta.projectId == null) meta.projectId = proj;
        for (const [key, value] of params.entries()) {
          if (key.startsWith('m.') || key.startsWith('meta.')) {
            const k = key.startsWith('m.') ? key.slice(2) : key.slice(5);
            if (k) meta[k] = value;
          }
        }
        return meta;
      })();

      // Build options
      const options = {
        webhookUrl,
        webhookConfig: { method, headers },
        target: targetSelector,
        mode, // 'window' | 'fullscreen'

        // Chat behavior keys
        chatInputKey: get('chatInputKey', 'chatInput'),
        chatSessionKey: get('chatSessionKey', 'sessionId'),
        loadPreviousSession: toBool(get('loadPreviousSession'), true),
        showWelcomeScreen: toBool(get('showWelcomeScreen'), false),
        enableStreaming: toBool(get('enableStreaming'), false),

        // Language & text
        defaultLanguage: get('defaultLanguage', 'en'),
        i18n: getComplex('i18n'),

        // Initial messages
        initialMessages: getComplex('initialMessages'),

        // Metadata (passed to workflow)
        metadata: resolvedMetadata,

        // File uploads
        allowFileUploads: toBool(get('allowFileUploads'), false),
        allowedFilesMimeTypes: get('allowedFilesMimeTypes', ''), // e.g. image/*,application/pdf
      };

      // Convenience: default i18nBlank=true to clear title/subtitle if no i18n was supplied (overridable with i18nBlank=false)
      const i18nBlank = toBool(get('i18nBlank'), true);
      if (i18nBlank && !options.i18n) {
        options.i18n = { [options.defaultLanguage]: { title: '', subtitle: '', footer: '', getStarted: '', inputPlaceholder: 'Type your question..' } };
      }

      // Debug helper: debug=true logs resolved options
      if (['1','true','yes','y','on'].includes(String(get('debug')).trim().toLowerCase())) {
        console.log('[n8n-chat-wrapper] Resolved options:', options);
      }

      // Initialize chat
      createChat(options);
    </script>
  </body>
</html>
